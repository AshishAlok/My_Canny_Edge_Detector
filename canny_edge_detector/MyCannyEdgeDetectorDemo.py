# -*- coding: utf-8 -*-
"""MyCannyEdgeDetectorDemo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wjIbDobPM_oI5YcLtqW-ux6RLU2GMCgT
"""

from skimage.color import rgb2gray
from skimage import feature
from skimage.transform import resize
from skimage.io import imread,imshow
from skimage import data
import numpy as np
from matplotlib import pyplot as plt
import math
import skimage



def convolve(image, kernel):
    assert( image.ndim == 2)
    assert( kernel.ndim == 2)
    image_height, image_width = image.shape
    height_kernel, widht_kernel = kernel.shape
    hk = height_kernel//2
    wk = widht_kernel//2
    new_img = np.pad(image, (hk, wk), 'constant', constant_values=0)
    pHi, pWi = new_img.shape
    out_image = np.zeros((image_height, image_width))
    for i in range(hk, pHi-hk):
        for j in range(wk, pWi-wk):
            img_mat = new_img[i-hk:i+hk+1, j-wk:j+wk+1]
            out_image[i-hk][j-wk] = np.sum(img_mat*kernel)
    
    return out_image

def gaussian_filter(image,sigma):
    # gaussian kernel size related to sigma by the relation below
    kernel = 2*math.ceil(3*sigma) + 1
    size = kernel//2

    h = np.zeros((kernel,kernel))

    x, y = np.mgrid[-size:size+1, -size :size+1]
    normalisation_constant = (2.0*np.pi*sigma*sigma)
    sigma_2 = (2*sigma*sigma)
    for i in range(kernel):
      for j in range(kernel):
        h[i][j] = np.exp(-((x[i][j]**2 + y[i][j]**2)/sigma_2))/normalisation_constant
    
    n,m = image.shape
    # print(n,m)
    # g = np.zeros((n,m))

    g = convolve(image,h)
    # print(g.shape)
    # plt.axis('off')
    # plt.imshow(g,cmap ='gray')
    return g

def sobel_filter(gauss_image):

  sobel_along_y = np.array([[1,2,1],[0,0,0],[-1,-2,-1]])
  sobel_along_x = np.array([[-1,0,1],[-2,0,2],[-1,0,1]])

  image_x = convolve(gauss_image, sobel_along_x)
  image_y = convolve(gauss_image, sobel_along_y)

  sobel_image = np.zeros(image_x.shape)
  n,m = image_x.shape

  for i in range(n):
    for j in range(m):
      sobel_image[i][j] = np.hypot(image_x[i][j],image_y[i][j])

  # taking the max value in the sobel_image as the threshhold value
  mx = sobel_image.max()

  for i in range(n):
    for j in range(m):
      sobel_image[i][j] = (sobel_image[i][j]/mx)*255

  sobel_angle = np.zeros(sobel_image.shape)

  for i in range(n):
    for j in range(m):
      sobel_angle[i][j] = np.arctan2(image_y[i][j],image_x[i][j])

  # fig, axarr = plt.subplots(1,3,figsize=(20,5)) 
  # axarr[0].imshow(sobel_image,cmap = 'gray')
  # axarr[0].set_title('Sobel')
  # axarr[0].axis('off')
  # axarr[1].imshow(image_x,cmap='gray')
  # axarr[1].set_title('Sobel_x')
  # axarr[1].axis('off')
  # axarr[2].imshow(image_y,cmap='gray')
  # axarr[2].set_title('Sobel_y')
  # axarr[2].axis('off')
  # plt.show()
  return sobel_image,sobel_angle

def non_max_suppression(gradient_int_matrix,edge_dir):
    n, m = gradient_int_matrix.shape
    suppressed_image = np.zeros((n,m))
    
    angle = edge_dir * 180. / np.pi
    # tan is periodic with 180 degrees
    angle[angle < 0] += 180

    
    for i in range(1,n-1):
        for j in range(1,m-1):
                pixel_1 = 255
                pixel_2 = 255
                
               #angle 0
                if (0 <= angle[i,j] < 22.5) or (157.5 <= angle[i,j] <= 180):
                    pixel_1 = gradient_int_matrix[i, j+1]
                    pixel_2 = gradient_int_matrix[i, j-1]
                #angle 45
                elif (22.5 <= angle[i,j] < 67.5):
                    pixel_1 = gradient_int_matrix[i+1, j-1]
                    pixel_2 = gradient_int_matrix[i-1, j+1]
                #angle 90
                elif (67.5 <= angle[i,j] < 112.5):
                    pixel_1 = gradient_int_matrix[i+1, j]
                    pixel_2 = gradient_int_matrix[i-1, j]
                #angle 135
                elif (112.5 <= angle[i,j] < 157.5):
                    pixel_1 = gradient_int_matrix[i-1, j-1]
                    pixel_2 = gradient_int_matrix[i+1, j+1]

                if (gradient_int_matrix[i,j] >= pixel_1) and (gradient_int_matrix[i,j] >= pixel_2):
                    suppressed_image[i,j] = gradient_int_matrix[i,j] 
                else:
                    suppressed_image[i,j] = 0

    return suppressed_image


def threshold(image, lowThresholdRatio, highThresholdRatio):
    
    highThreshold = image.max() * highThresholdRatio
    lowThreshold = highThreshold * lowThresholdRatio
    
    n, m = image.shape

    output_image = np.zeros((n,m), dtype=np.int32)
    
    weak_intensity = np.int32(25)
    strong_intensity = np.int32(255)
    
    for i in range(n):
      for j in range(m):
        if image[i][j]>=highThreshold :
          output_image[i][j] = strong_intensity
        elif (image[i][j]< highThreshold) and (image[i][j] >= lowThreshold):
          output_image[i][j] = image[i][j]

    
    return (output_image, weak_intensity, strong_intensity)

def hysteresis(image, weak, strong=255):
    n, m = image.shape  
    for i in range(1, n-1):
        for j in range(1, m-1):
            if (image[i][j] == weak):
               
                if ((image[i+1][j-1] == strong) or (image[i+1][ j] == strong) or (image[i+1][ j+1] == strong)
                    or (image[i][j-1] == strong) or (image[i][j+1] == strong)
                    or (image[i-1][ j-1] == strong) or (image[i-1][ j] == strong) or (image[i-1][ j+1] == strong)):
                    image[i][j] = strong
                else:
                    image[i][j] = 0
    return image

def myCannyEdgeDetector(input_image,low_threshold,high_threshold):

  
  input_image = rgb2gray(input_image)
  input_image = resize(input_image,(640,480),anti_aliasing=True)
  gauss_image = gaussian_filter(input_image,1)
  gradient_mat,edge_dir = sobel_filter(gauss_image)

  double_thresholding = non_max_suppression(gradient_mat,edge_dir)

  hysteresis_image ,weak_intensity,strong_intensity = threshold(double_thresholding,low_threshold,high_threshold)

  final_image = hysteresis(hysteresis_image,weak_intensity,strong_intensity)
  final_image = resize(final_image,(640,480),anti_aliasing = True)
  n,m=final_image.shape
  skimage_canny = feature.canny(input_image) 

  print("PSNR",skimage.metrics.peak_signal_noise_ratio(skimage_canny,final_image))
  print("SSIM",skimage.metrics.structural_similarity(skimage_canny,final_image))

  fig, axarr = plt.subplots(1,2,figsize=(10,10)) 
  axarr[0].imshow(skimage_canny,cmap = 'gray')
  axarr[0].set_title('skimage CannyEdgeDetector')
  axarr[0].axis('off')
  axarr[1].imshow(final_image,cmap='gray')
  axarr[1].set_title('MyCannyEdgeDetector')
  axarr[1].axis('off')
  plt.show()


input_image = data.camera()
myCannyEdgeDetector(input_image,0.06,0.1)

